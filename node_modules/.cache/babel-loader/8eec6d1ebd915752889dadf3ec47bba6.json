{"ast":null,"code":"/**\n * index.js\n *\n * a request API compatible with window.fetch\n */\n\nvar parse_url = require('url').parse;\nvar resolve_url = require('url').resolve;\nvar http = require('http');\nvar https = require('https');\nvar zlib = require('zlib');\nvar stream = require('stream');\nvar Body = require('./lib/body');\nvar Response = require('./lib/response');\nvar Headers = require('./lib/headers');\nvar Request = require('./lib/request');\nvar FetchError = require('./lib/fetch-error');\n\n// commonjs\nmodule.exports = Fetch;\n// es6 default export compatibility\nmodule.exports.default = module.exports;\n\n/**\n * Fetch class\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction Fetch(url, opts) {\n  // allow call as function\n  if (!(this instanceof Fetch)) return new Fetch(url, opts);\n\n  // allow custom promise\n  if (!Fetch.Promise) {\n    throw new Error('native promise missing, set Fetch.Promise to your favorite alternative');\n  }\n  Body.Promise = Fetch.Promise;\n  var self = this;\n\n  // wrap http.request into fetch\n  return new Fetch.Promise(function (resolve, reject) {\n    // build request object\n    var options = new Request(url, opts);\n    if (!options.protocol || !options.hostname) {\n      throw new Error('only absolute urls are supported');\n    }\n    if (options.protocol !== 'http:' && options.protocol !== 'https:') {\n      throw new Error('only http(s) protocols are supported');\n    }\n    var send;\n    if (options.protocol === 'https:') {\n      send = https.request;\n    } else {\n      send = http.request;\n    }\n\n    // normalize headers\n    var headers = new Headers(options.headers);\n    if (options.compress) {\n      headers.set('accept-encoding', 'gzip,deflate');\n    }\n    if (!headers.has('user-agent')) {\n      headers.set('user-agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n    }\n    if (!headers.has('connection') && !options.agent) {\n      headers.set('connection', 'close');\n    }\n    if (!headers.has('accept')) {\n      headers.set('accept', '*/*');\n    }\n\n    // detect form data input from form-data module, this hack avoid the need to pass multipart header manually\n    if (!headers.has('content-type') && options.body && typeof options.body.getBoundary === 'function') {\n      headers.set('content-type', 'multipart/form-data; boundary=' + options.body.getBoundary());\n    }\n\n    // bring node-fetch closer to browser behavior by setting content-length automatically\n    if (!headers.has('content-length') && /post|put|patch|delete/i.test(options.method)) {\n      if (typeof options.body === 'string') {\n        headers.set('content-length', Buffer.byteLength(options.body));\n        // detect form data input from form-data module, this hack avoid the need to add content-length header manually\n      } else if (options.body && typeof options.body.getLengthSync === 'function') {\n        // for form-data 1.x\n        if (options.body._lengthRetrievers && options.body._lengthRetrievers.length == 0) {\n          headers.set('content-length', options.body.getLengthSync().toString());\n          // for form-data 2.x\n        } else if (options.body.hasKnownLength && options.body.hasKnownLength()) {\n          headers.set('content-length', options.body.getLengthSync().toString());\n        }\n        // this is only necessary for older nodejs releases (before iojs merge)\n      } else if (options.body === undefined || options.body === null) {\n        headers.set('content-length', '0');\n      }\n    }\n    options.headers = headers.raw();\n\n    // http.request only support string as host header, this hack make custom host header possible\n    if (options.headers.host) {\n      options.headers.host = options.headers.host[0];\n    }\n\n    // send request\n    var req = send(options);\n    var reqTimeout;\n    if (options.timeout) {\n      req.once('socket', function (socket) {\n        reqTimeout = setTimeout(function () {\n          req.abort();\n          reject(new FetchError('network timeout at: ' + options.url, 'request-timeout'));\n        }, options.timeout);\n      });\n    }\n    req.on('error', function (err) {\n      clearTimeout(reqTimeout);\n      reject(new FetchError('request to ' + options.url + ' failed, reason: ' + err.message, 'system', err));\n    });\n    req.on('response', function (res) {\n      clearTimeout(reqTimeout);\n\n      // handle redirect\n      if (self.isRedirect(res.statusCode) && options.redirect !== 'manual') {\n        if (options.redirect === 'error') {\n          reject(new FetchError('redirect mode is set to error: ' + options.url, 'no-redirect'));\n          return;\n        }\n        if (options.counter >= options.follow) {\n          reject(new FetchError('maximum redirect reached at: ' + options.url, 'max-redirect'));\n          return;\n        }\n        if (!res.headers.location) {\n          reject(new FetchError('redirect location header missing at: ' + options.url, 'invalid-redirect'));\n          return;\n        }\n\n        // per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET when following redirect\n        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && options.method === 'POST') {\n          options.method = 'GET';\n          delete options.body;\n          delete options.headers['content-length'];\n        }\n        options.counter++;\n        resolve(Fetch(resolve_url(options.url, res.headers.location), options));\n        return;\n      }\n\n      // normalize location header for manual redirect mode\n      var headers = new Headers(res.headers);\n      if (options.redirect === 'manual' && headers.has('location')) {\n        headers.set('location', resolve_url(options.url, headers.get('location')));\n      }\n\n      // prepare response\n      var body = res.pipe(new stream.PassThrough());\n      var response_options = {\n        url: options.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: options.size,\n        timeout: options.timeout\n      };\n\n      // response object\n      var output;\n\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no content-encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n      if (!options.compress || options.method === 'HEAD' || !headers.has('content-encoding') || res.statusCode === 204 || res.statusCode === 304) {\n        output = new Response(body, response_options);\n        resolve(output);\n        return;\n      }\n\n      // otherwise, check for gzip or deflate\n      var name = headers.get('content-encoding');\n\n      // for gzip\n      if (name == 'gzip' || name == 'x-gzip') {\n        body = body.pipe(zlib.createGunzip());\n        output = new Response(body, response_options);\n        resolve(output);\n        return;\n\n        // for deflate\n      } else if (name == 'deflate' || name == 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        var raw = res.pipe(new stream.PassThrough());\n        raw.once('data', function (chunk) {\n          // see http://stackoverflow.com/questions/37519828\n          if ((chunk[0] & 0x0F) === 0x08) {\n            body = body.pipe(zlib.createInflate());\n          } else {\n            body = body.pipe(zlib.createInflateRaw());\n          }\n          output = new Response(body, response_options);\n          resolve(output);\n        });\n        return;\n      }\n\n      // otherwise, use response as-is\n      output = new Response(body, response_options);\n      resolve(output);\n      return;\n    });\n\n    // accept string, buffer or readable stream as body\n    // per spec we will call tostring on non-stream objects\n    if (typeof options.body === 'string') {\n      req.write(options.body);\n      req.end();\n    } else if (options.body instanceof Buffer) {\n      req.write(options.body);\n      req.end();\n    } else if (typeof options.body === 'object' && options.body.pipe) {\n      options.body.pipe(req);\n    } else if (typeof options.body === 'object') {\n      req.write(options.body.toString());\n      req.end();\n    } else {\n      req.end();\n    }\n  });\n}\n;\n\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nFetch.prototype.isRedirect = function (code) {\n  return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nFetch.Promise = global.Promise;\nFetch.Response = Response;\nFetch.Headers = Headers;\nFetch.Request = Request;","map":null,"metadata":{},"sourceType":"script"}